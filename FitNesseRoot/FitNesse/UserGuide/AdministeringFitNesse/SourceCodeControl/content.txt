!2 Git-native doc store (recommended)
FitNesse now supports a native Git-backed doc store with history UI and conflict handling. When enabled, every page save writes to the working tree and creates a git commit (with author inferred from authentication when available). Conflict handling supports configurable merge strategies (fast-forward, merge, rebase, squash, ours, theirs) and a manual resolution path when auto-merge is unsafe. The history, diff, and revert views surface git commits directly in the UI.

Key behaviors:
 * Page content, properties, and attachments are written to the git working tree in the standard !-FitNesse-! layout.
 * Commits use a deterministic message template (e.g., !-wiki: update <PagePath>-!) and include optional reason/correlation data from the UI.
 * Merge strategy is configurable per environment; unresolved conflicts are surfaced to the user rather than committed with inline markers.
 * History and diff screens read from git; revert creates a new commit that restores the selected version.

Compatibility:
 * Existing !-FitNesseRoot-! folders still work unchanged.
 * A filesystem-only mode remains available for air-gapped or read/write sandbox setups.

Configuration:
 * Select git-native doc storage in your server configuration (Vert.x env or config file).
 * Choose merge strategy and author mapping (e.g., map authenticated users to git author/email).
 * Repo must be initialized; the server can commit on save once the working tree exists.

!2 Safe defaults
 * Use a dedicated repo per wiki and a service committer name/email (set !-FITNESSE_GIT_COMMITTER_NAME-! and !-FITNESSE_GIT_COMMITTER_EMAIL-!) so audit trails stay consistent.
 * Keep !-FITNESSE_GIT_MERGE_STRATEGY=FAST_FORWARD-! unless you explicitly need merge commits or rebases.
 * Enable auth so author mapping is populated; otherwise commits fall back to the service user.

!2 Migration steps (filesystem to git-native)
 * Stop the server to avoid writes during migration.
 * Copy the wiki into a new repo and create the initial commit:
   * !style_code(./gradlew copyRuntimeLibs)
   * !style_code(java -cp build/classes/java/main:build/resources/main:lib/* fitnesseMain.GitMigrateMain --from FitNesseRoot --to /path/to/wiki-repo --initRepo true)
 * Point your server at the new repo root and restart.

!2 Conflict handling (what users see)
When two edits overlap, the server detects the conflict and blocks the save until it is resolved, instead of committing inline conflict markers.

!plantuml
@startuml
actor User
participant "FitNesse UI" as UI
participant "GitDocStore" as Store
User -> UI: Save page
UI -> Store: writePage(expectedVersion)
Store -> Store: attempt merge strategy
alt no conflict
  Store --> UI: commit + new version
  UI --> User: Save succeeded
else conflict
  Store --> UI: conflict payload
  UI --> User: resolve + retry
end
@enduml
!endplantuml

!2 Legacy version controllers (still available)
It is relatively simple to marry !-FitNesse-! to your source code control system. By default FitNesse is using a Zip-file based version control mechanism. As soon as a page is updated, a backup is made of the current version and the new version is put into place. Closely tied to the version controller is the .RecentChanges page. This page can be consulted to see who change what.

The most basic implementation is the !-SimpleFileVersionsController-!. It just stores the content. This class is used as a basis for the !-ZipFileVersionsController-! and [[!-Git versions controller-!][https://github.com/amolenaar/fitnesse-git-plugin]].

!2 Description of !-fitnesse.wiki.fs.VersionsController-!
To create a version controller 3 things are important:

 1 The pages should be stored in a File system. The filesystem based wiki page is currently the only supported page type (but you're free to create your own)
 1 You'll need to implement the !-fitnesse.wiki.fs.VersionsController-! interface.
 1 To support recent changes you'll have to provide a class that implements the !-fitnesse.wiki.RecentChanges-! interface.

The !-VersionsController-! interface is quite straightforward. All the relevant information is provided through the !-fitnesse.wiki.fs.FileVersion-! interface. This interface provides the file name, content, author and time information.

The !-VersionsController-! interface consists of the following methods:

{{{  VersionInfo makeVersion(FileVersion... fileVersion) throws IOException;}}}Create a new version/revision. This is typically called then a page is saved. Each !-FileVersion-! contains infomation about the file that is to be saved, the author and the content. Time information is usually less important. It might be that the author information is taken from the first file version provided (since all changes are to be saved as one commit anyway). Note that, since files are saved in directories, the directories are not mentioned as files-to-be-saved. It's up to the versions controller to take care of this.

{{{  FileVersion[] getRevisionData(String revision, File... files);}}}Get a specific version of the files requested, given a revision indentifier. The label is either a property also provided by the !-VersionInfo-! object (typically name) or null, denoting the most recent version.

{{{  Collection<? extends VersionInfo> history(File... files);}}}Obtain the history of a page. The history is as big as the depth set by setHistoryDepth(int) (see below).

{{{  void addDirectory(FileVersion... files) throws IOException;}}}Create a new (versioned) directory. This operation is called from the http://files/ handlers.

{{{  void rename(FileVersion fileVersion, File originalFile) throws IOException;}}}Rename a versioned file. This operation is called from the http://files/ handlers.

{{{  void delete(FileVersion... files);}}}Delete the page. The author has to be set to the user performing the delete operation.

{{{  void setHistoryDepth(int historyDepth);}}}Configure the depth for which versions need to be stored (in case of zip files) or the history depth for which changes are fetched (see history() above)

!2 What happened to !-CmSystem-!?
In older versions the convention was to create a !-CmSystem-! class: a class that fulfilled the !-CmSystem-! protocol. Although this appeared to work fine on paper the real world version had some downsides. For one it was not in control with the saving of the content, now the !-VersionsController-! is in charge of this. Also the protocol was quite cumbersome and it involved Java introspection logic to get it working. Why does your wiki page have to "know" about version control anyway...

The !-VersionsController-! solution will be more solid can be made to provide generic solutions towards version control in FitNesse.
